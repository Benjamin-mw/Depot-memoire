---
title: "GLM"
author: "Dudot Lucas - Lapaz Eudes - Moinard Benjamin - Nanoux Louis"
date: "2023-01-30"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, echo = TRUE, message = FALSE, error = FALSE}
library(FactoMineR)
library(factoextra)
library(CASdatasets)
library(tidyverse)
library(MASS)
library(knitr)
library(ggplot2)
library(cowplot)
library(reshape2)
library(dplyr)
library(GGally)
library(corrplot)
library(carData) 
library(car)
library(questionr)
library(multcomp)
library(dplyr)
library(leaps)
library(TeachingDemos)
library(factoextra)
library(ROCR)
library(plotROC)
library(caret)
```

# GLM pour la variable coût

## Transformation de certaines variables en variables catégorielles

```{r}
data(freMPL5)
```

Notre variable "ClaimAmount" est une variable quantitative et représente le prix total des accidents survenus au cours de l'année pour chacun des assurés.

Cette variable prend ainsi une valeur nulle lorque la variable "ClaimInd" a la valeur nulle, c'est-à-dire si aucun accident n'est survenu et prend des valeurs positives dans le cas contraire.

```{r}
summary(freMPL5$ClaimAmount)
```

Seulement, nos données présentent des cas particuliés et isolés dans laquelle la variable ClaimAmount prend des valeurs négatives. Nous élimineront ces données dans la suite de notre étude de la variable et nous nous intéresserons aux valeurs que celle-ci peut prendre lorsqu'un incident a lieu.

Nous utiliserons également le même découpage réalisé lors de l'étude de la variable fréquence.

```{r}
#enlever les valeurs négatives
freMPL5 <- subset(freMPL5, freMPL5$ClaimAmount >= 0)

#passer en variables catégorielles
freMPL5$HasKmLimit <- factor(freMPL5$HasKmLimit)
freMPL5$RiskArea <- factor(freMPL5$RiskArea)
freMPL5$ClaimInd <- factor(freMPL5$ClaimInd)

#segmentation des tranches d'âge
freMPL5$DrivAge_fact <- cut(freMPL5$DrivAge, c(20,25,30,35,40,45,50,58,65,120), include.lowest = TRUE)

#Découpage CSP
freMPL5$Categ = 0
freMPL5$Categ[freMPL5$SocioCateg == "CSP50"] = 1
freMPL5$Categ[freMPL5$SocioCateg == "CSP55"] = 2
freMPL5$Categ[freMPL5$SocioCateg == "CSP60"] = 3
freMPL5$Categ[freMPL5$SocioCateg == "CSP1"] = 4
freMPL5$Categ[freMPL5$SocioCateg == "CSP42"] = 5
freMPL5$Categ[freMPL5$SocioCateg == "CSP46"] = 6
freMPL5$Categ[freMPL5$SocioCateg == "CSP48"] = 7
freMPL5$Categ[freMPL5$SocioCateg == "CSP66"] = 8
freMPL5$Categ = factor(freMPL5$Categ)
```

Le coefficient de bonus-malus est réglementaire, ne faut-il pas le rajouter que plus tard dans la tarification ?

Nous allons faire un système à double pénalisation, "BonusMalus" sera pris en compte dans nos GLMs et notre grille de tarification

## Première estimation de la loi de notre variable "ClaimAmount"

```{r, error = TRUE}
cout <- freMPL5[freMPL5$ClaimInd == 1,]
```

```{r}
summary(cout$ClaimAmount)
```

```{r}
alpha = mean(cout$ClaimAmount)^2/var(cout$ClaimAmount)
beta = mean(cout$ClaimAmount)/var(cout$ClaimAmount)
qqplot (cout$ClaimAmount, qgamma ( ppoints (cout$ClaimAmount,3/8), shape =alpha, rate =beta),
        	xlab ="Prix des sinistres observés",
        main ="Graphique des quantiles pour les prix des sinistres (loi gamma).")
abline (a=0,b=1, col ="red")
```

La loi gamma semble très bien s'adapter à notre modèle

```{r}
qqplot (cout$ClaimAmount, qnorm ( ppoints (cout$ClaimAmount,3/8), mean =mean(cout$ClaimAmount), sd =sqrt(var(cout$ClaimAmount))),
        	xlab ="Prix des sinistres observés",
        main ="Graphique des quantiles pour les prix des sinistres (loi normale).")
abline (a=0,b=1, col ="red")
```

La loi normale ne semble pas être très adaptée à notre modèle

```{r}
#le graphique suivant sur le qqplot de notre loi lognormal ne marche pas car la variance de notre variable est très elvé ce qui fait que lorque l'on la passe à l'exponentielle, on obtient m= INF
m <- exp(mean(cout$ClaimAmount)+var(cout$ClaimAmount)/2)
var <- exp(2*m+var(cout$ClaimAmount))*(exp(var(cout$ClaimAmount))-1)
qqplot (cout$ClaimAmount, qlnorm ( ppoints (cout$ClaimAmount,3/8), mean = m, sd = var),
        	xlab ="Prix des sinistres observés",
        main ="Graphique des quantiles pour les prix des sinistres (loi log normale).")
abline (a=0,b=1, col ="red")
```

## Séparation en échantillon apprentissage et échantillon test

```{r}
perm <- sample(nrow(cout),80/100*nrow(cout))
train <- cout[perm,]
test <- cout[-perm,]

```

## Loi gamma

```{r}
train <- subset(train, train$ClaimAmount <60000)
summary(train$ClaimAmount)
```

```{r}
gamma.inv <- glm(ClaimAmount ~ MariStat+Categ+VehUsage+HasKmLimit+ClaimNbResp+ClaimNbNonResp+ClaimNbParking+ClaimNbFireTheft+ClaimNbWindscreen+OutUseNb+RiskArea+BonusMalus+DrivAge_fact, data = train, family = Gamma(link = "inverse"))
summary(gamma.inv)
```

Il n'affiche pas de GLM. Essayons d'enlever les valeurs extrêmes

```{r}
gamma.log <- glm(ClaimAmount ~ MariStat+Categ+VehUsage+HasKmLimit+ClaimNbResp+ClaimNbNonResp+ClaimNbParking+ClaimNbFireTheft+ClaimNbWindscreen+OutUseNb+RiskArea+BonusMalus+DrivAge_fact, data = train, family = Gamma(link = "log"))

gamma.id <- glm(ClaimAmount ~ MariStat+Categ+VehUsage+HasKmLimit+ClaimNbResp+ClaimNbNonResp+ClaimNbParking+ClaimNbFireTheft+ClaimNbWindscreen+OutUseNb+RiskArea+BonusMalus+DrivAge_fact, data = train, family = Gamma(link = "identity"))

```

Apparition d'un message d'erreur :

"glm.fit : l'algorithme n'a pas convergé"

```{r}
gamma.log$converged
```

```{r}
summary(gamma.log)
summary(gamma.id)
```

Il y a ainsi peu de différence entre les critères d'AIC entre les différentes fonctions de lien

### Both, forward and backward

```{r}
mod0 <- glm(ClaimAmount ~ 1, data = train, family = Gamma(link = "log"))
```

```{r}
modBoth = step(gamma.log, mod0, trace=F,direction = c('both'))
summary(modBoth)
```

```{r}
modBack = step(gamma.log, mod0, trace=F,direction = c('backward'))
summary(modBack)
```

```{r}
modFor = step(gamma.log, mod0, trace=F,direction = c('forward'))
summary(modFor)
```

### Prediction

```{r}
estimation <- gamma.log$fitted.values
hist(estimation)
```

```{r}
prediction <- predict.glm(gamma.log, newdata = test, type = "response")
hist(prediction)
```

### RMSE

```{r}
RMSE_train <- sqrt(mean(modBoth$residuals^2))
RMSE_train
```

## Loi Gaussienne 

### 1er Modele

```{r}
gauss.id <- glm(ClaimAmount ~ MariStat+Categ+VehUsage+HasKmLimit+ClaimNbResp+ClaimNbNonResp+ClaimNbParking+ClaimNbFireTheft+ClaimNbWindscreen+OutUseNb+RiskArea+BonusMalus+DrivAge_fact, data = train, family = gaussian(link = "identity"))
summary(gauss.id)
```

Un systeme dont les variables interessantes sont bien:

(BonusMalus, RiskArea12, ClaimNbResp, ClaimNbNonResp et Categ3)

```{r}
gauss.log <- glm(ClaimAmount ~ MariStat+Categ+VehUsage+HasKmLimit+ClaimNbResp+ClaimNbNonResp+ClaimNbParking+ClaimNbFireTheft+ClaimNbWindscreen+OutUseNb+RiskArea+BonusMalus+DrivAge_fact, data = train, family = gaussian(link = "log"))
summary(gauss.log)

gauss.inv <- glm(ClaimAmount ~ MariStat+Categ+VehUsage+HasKmLimit+ClaimNbResp+ClaimNbNonResp+ClaimNbParking+ClaimNbFireTheft+ClaimNbWindscreen+OutUseNb+RiskArea+BonusMalus+DrivAge_fact, data = train, family = gaussian(link = "inverse"))
summary(gauss.inv)
```

La fonction de lien log pour la loi gaussienne a des variables tres interessantes à prendre en compte

(notamment tous les types d'accidents, les conducteurs âgés, BonusMalus, RiskArea12 et certaines classes sociales)

### Both,backward and forward

```{r}
mod0 <- glm(ClaimAmount ~ 1, data = train, family = gaussian(link = "identity"))
```

```{r}
modBoth = step(gauss.id, mod0, trace=F,direction = c('both'))
summary(modBoth)
```

### Prediction

```{r}
estimation <- gauss.id$fitted.values
hist(estimation)

prediction <- predict.glm(gauss.id, newdata = test, type = "response")
hist(prediction)
```

## Loi Gaussienne Inverse

### 1er Modele

```{r}
invgauss.mu <- glm(ClaimAmount ~ MariStat+Categ+VehUsage+HasKmLimit+ClaimNbResp+ClaimNbNonResp+ClaimNbParking+ClaimNbFireTheft+ClaimNbWindscreen+OutUseNb+RiskArea+BonusMalus+DrivAge_fact, data = train, family = inverse.gaussian(link = "1/mu^2"))
summary(invgauss.mu)
```

```{r}
invgauss.id <- glm(ClaimAmount ~ MariStat+Categ+VehUsage+HasKmLimit+ClaimNbResp+ClaimNbNonResp+ClaimNbParking+ClaimNbFireTheft+ClaimNbWindscreen+OutUseNb+RiskArea+BonusMalus+DrivAge_fact, data = train, family = inverse.gaussian(link = "identity"))

invgauss.inv <- glm(ClaimAmount ~ MariStat+Categ+VehUsage+HasKmLimit+ClaimNbResp+ClaimNbNonResp+ClaimNbParking+ClaimNbFireTheft+ClaimNbWindscreen+OutUseNb+RiskArea+BonusMalus+DrivAge_fact, data = train, family = inverse.gaussian(link = "inverse"))

invgauss.log <- glm(ClaimAmount ~ MariStat+Categ+VehUsage+HasKmLimit+ClaimNbResp+ClaimNbNonResp+ClaimNbParking+ClaimNbFireTheft+ClaimNbWindscreen+OutUseNb+RiskArea+BonusMalus+DrivAge_fact, data = train, family = inverse.gaussian(link = "log"))
```

### Both, Backward and Forward

### Prediction

## Loi Log Normale

### 1er Modele

### Both, Backward and Forward

### Prediction

# GLM pour la variable fréquence

On remarque que la variable à étudier vaut uniquement 0 ou 1 (indique si l'assuré a eu un sinistre ou non). Nous allons donc dans un premier temps la modéliser par une loi de Bernoulli. Cette fois-ci, on prend le jeu de données complet (pas uniquement les assurés ayant eu des sinistres évidemment, contrairement à la partie précédente).

Habituellement, on utilise une approche fréquence-sévérité où la fréquence est le nombre d'accidents que l'assuré a obtenu. Cependant, on aura ici que la fréquence est soit 1, soit 0 selon le fait qu'il ait eu un sinistre ou pas.

Nous aurons donc la formule suivante :

$$
E[X_i]=E[F_i] \cdot E[B_i]
$$

avec $B_i$ la variable de coût moyen et $F_i$ la variable de fréquence qui sera une $Ber(q_i)$ donc

$$
E[F_i] = q_i
$$

d'où

$$
E[X_i]=q_i \cdot E[B_i]
$$

**Remarque :**

Les variables ClaimNbResp, ClaimNbNonResp, ClaimNbParking, ClaimNbFireTheft, ClaimNbWindscreen, OutUseNb traitent des sinistres passés durant les 4 années précédentes. Ils permettront peut-être de déterminer si l'assuré a des risques d'avoir de nouveau ce genre de sinistres qui sont plus ou moins coûteux selon leur classification.

```{r}
#on veut reprendre les lignes où ClaimAmout pouvait aussi être nul
data(freMPL5)
freMPL5$HasKmLimit <- factor(freMPL5$HasKmLimit)
freMPL5$RiskArea <- factor(freMPL5$RiskArea)
freMPL5$ClaimInd <- factor(freMPL5$ClaimInd)

freMPL5$DrivAge_fact <- cut(freMPL5$DrivAge, c(20,25,30,35,40,45,50,58,65,120), include.lowest = TRUE)
```

```{r}
glm(ClaimInd ~ MariStat+SocioCateg+VehUsage+HasKmLimit+ClaimNbResp+ClaimNbNonResp+ClaimNbParking+ClaimNbFireTheft+ClaimNbWindscreen+OutUseNb+RiskArea+BonusMalus+DrivAge_fact, data = freMPL5, offset = Exposure, family = binomial(link = logit))
```

```{r}
bin.prob <-glm(ClaimInd ~ MariStat+SocioCateg+VehUsage+HasKmLimit+ClaimNbResp+ClaimNbNonResp+ClaimNbParking+ClaimNbFireTheft+ClaimNbWindscreen+OutUseNb+RiskArea+BonusMalus+DrivAge_fact, data = freMPL5, offset = Exposure, family = binomial(link = probit) )
summary(bin.prob)
```

Le ratio "residual deviance/ degrés de liberté" est de 0.57190... qui est inférieur à 1, il n'y aurait pas de problème d'overfeating. Il ne serait pas nécessaire de passer par les quasi-lois mais faisons le quand même.

```{r}
glm(ClaimInd ~ MariStat+SocioCateg+VehUsage+HasKmLimit+ClaimNbResp+ClaimNbNonResp+ClaimNbParking+ClaimNbFireTheft+ClaimNbWindscreen+OutUseNb+RiskArea+BonusMalus+DrivAge_fact, data = freMPL5, offset = Exposure, family = quasibinomial(link = logit) )
```

Il y a ici encore plein de catégories socio-professionnelles à enlever ou regrouper.

```{r}
freMPL5 <- subset(freMPL5, freMPL5$SocioCateg != "CSP30" & freMPL5$SocioCateg !="CSP45" & freMPL5$SocioCateg !="CSP63" & freMPL5$SocioCateg !="CSP61")

perm <- sample(nrow(freMPL5),80/100*nrow(freMPL5))
freMPL5.train <- freMPL5[perm,]
freMPL5.test <- freMPL5[-perm,]
```

```{r}
summary(freMPL5.train$ClaimInd)
summary(freMPL5.test$ClaimInd)
```

```{r}
bin.log <- glm(ClaimInd ~ MariStat+SocioCateg+VehUsage+HasKmLimit+ClaimNbResp+ClaimNbNonResp+ClaimNbParking+ClaimNbFireTheft+ClaimNbWindscreen+OutUseNb+RiskArea+BonusMalus+DrivAge_fact, data = freMPL5.train, offset = Exposure, family = binomial(link = logit))
summary(bin.log)
```

```{r}
prediction <- predict.glm(bin.log, newdata = freMPL5.test, type = "response")
summary(prediction)
hist(prediction)
```

```{r}
estimation <- bin.log$fitted.values
summary(estimation)
hist(estimation)
```

problème: dans SocioCateg, il y a CSP30 qui apparait dans test mais pas dans train

## Methode backward, forward, both

```{r}
mod0 <- glm(ClaimInd ~ 1, data = freMPL5.train, offset = Exposure, family = binomial(link = logit))
```

```{r}
modFor=step(bin.log, mod0, trace=F,direction = c('forward'))
summary(modFor)
```

```{r}
modBack=step(bin.log, mod0, trace=F,direction = c('backward'))
summary(modBack)
```

```{r}
modBoth=step(bin.log, mod0, trace=F,direction = c('both'))
summary(modBoth)
```

```{r}
summary(modBoth)
```

## RMSE (root mean squared error)

```{r}
RMSE_train <- sqrt(mean(modBoth$residuals^2))
RMSE_train
```

```{r}
bin.log2 <- glm(ClaimInd ~ SocioCateg+VehUsage+HasKmLimit+ClaimNbResp+ClaimNbNonResp+ClaimNbParking+ClaimNbFireTheft+ClaimNbWindscreen+RiskArea+BonusMalus, data = freMPL5.test, offset = Exposure, family = binomial(link = logit))

RMSE_test <- sqrt(mean(bin.log2$residuals^2))
RMSE_test
```

## MAE (mean absolute error)

```{r}
MAE_train <- mean(abs(modBoth$residuals))
MAE_train
```

## AUC, Courbe ROC

### Sur l'échantillon train

```{r}
pred=prediction(bin.log$fitted.values, freMPL5.train$ClaimInd)
perf=performance(pred,"tpr", "fpr")

auc_ROCR <- performance(pred, measure = "auc")
(auc_ROCR <- round(auc_ROCR@y.values[[1]],3) )
```

### Sur l'échantillon test

```{r}
prev_step <- predict(modBoth,newdata=freMPL5.test,type="response")
prev_prob <- data.frame(complet=predict(bin.log,newdata=freMPL5.test, type="response"),step=predict(modBoth,newdata=freMPL5.test,type="response"))
head(round(prev_prob,3), n=3)
```

```{r}
prev_class <- apply(prev_prob>0.5,2,factor,labels=1)
head(prev_class, n=3)
```

```{r}
mean(as.factor(prev_class[,1])==freMPL5.test$ClaimInd)
```

```{r}
mean(as.factor(prev_class[,2])==freMPL5.test$ClaimInd)
```

## Matrice de confusion

```{r}
score <- ifelse(predict(bin.log,freMPL5.test,type="response") >.3, "sinistre","sans sinistre")
confusion.mat = table(freMPL5.test$ClaimInd, score)  
fauxneg = confusion.mat[2,1]
fauxpos = confusion.mat[1,2]
vraisneg = confusion.mat[1,1]
vraispos = confusion.mat[2,2]
(txerr = (fauxneg+fauxpos) / (fauxneg+fauxpos+vraisneg+vraispos))
```

taux d'erreur de 10% environ

```{r}
sensibilite <- vraispos / (vraispos + fauxneg)   
precision <- vraispos / (vraispos + fauxpos) 
specificite <- vraisneg / (vraisneg + fauxpos)
(danger <- fauxneg / (fauxneg+vraisneg))
```

Ce modèle va considérer que 9,6% des non sinistrés aurait un sinistre

```{r}
confusion.mat
```

## Cross Validation

```{r}
fit.control <- trainControl(method = "repeatedcv", number = 5, repeats = 10)

fit <- train(ClaimInd ~ MariStat + Categ + VehUsage + HasKmLimit + 
    ClaimNbResp + ClaimNbNonResp + ClaimNbParking + ClaimNbFireTheft + 
    ClaimNbWindscreen + OutUseNb + RiskArea + BonusMalus + DrivAge_fact,
    data = freMPL5.train, method = "glm", 
    family = "binomial", trControl = fit.control)
```
